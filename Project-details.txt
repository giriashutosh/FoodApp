Foody (Name of the application)

Components

Header
  -Logo
  -Nav Items
Body
  -Search
  -RestaurantContainer
   -RestaurantCard
Footer
  - CopyRight
  - Links
  - Address
  - Contact

Props are used to pass data dynamically. it is just an argument pass to a function.
Destructuring on the fly ({name, cuisine})
config driven UI - website driven by data. controlling UI using the data(config).
cloudinary is a CDN.
why we need keys in map in react.
Don't use index as Keys react official

Two kind of export and import one is default and one is named(const).
named used when we have to export multiple things or component or function or variables.

React do fast, efficient DOM manipulation because of virtual DOM.
React Hooks
Normal js utility function
important hooks useState() and useEffect().
whenever a state variable updates react rerender the component.

Reconciliation algo or React Fiber introduced in React16 it is a new way of finding the diff and updated the DOM.
virtual DOM is a representation of actual DOM structure.
virtual DOM is basically looks like an js object.

Diff algo- Find out the difference between updated virtual DOM and previous virtual DOM.

Done
1. code splitting in the Components
2. utils folder for static data like image and api.
3. filter logic.

Done
add useEffect
call swiggy API
optional chaining
spinner loader instead use shimmer UI - load fake page until we get data from API.
conditional rendering
CORS policy - our browser does not allow to call api from one origin to another.
CORS chrome extension
add search functionality
add filter logic as per search

Need to be Done
Add login button
install react-router-dom
router configuration
create About page
Add contact us page
Add err page and then add to router path
use useRouteError
childrenRoute
use outlet to fill the children in Applayout
Add link to header like Home, etc
Add different page for different Restaurant using dynamic route.
create resMenu page
use Hook useParams

Monolith and Microservice Architecture
Monolith - for example all the API code, backend, DB connectivity, UI, Auth, sms all the code written in same project known as Monolith.
If we make any minor changes in the project in that case also need to compile the whole project and deploy.
Microservice - Different services for different job. all the services combined and make a whole project.
this is known as separation of concern and SRP.
All these services need to talk to each other.
can written multiple service in different languages.
All the services deployed on different port/server.
All the services has domain name corresponding to port or server whenever services need to interact with each other they call the URL.

Two ways to fetch the data from api.
1. As soon as page load we can make an api call then render it on the page.
2. As soon as the page load we will quickly render UI after this we make api call then re re-render with the new data.
2nd approach is better.


why we need state?
In case of normal variable if we change it dynamically that variable's value changes but does not re-render the UI.
React has no way to track whether a normal variable got updated or not.

whenever state variables update, react triggers a Reconciliation cycle (re-renders the component).

useEffect called everytime component render but dependency array changes it behaviour.
If no dependency array it will execute everytime.
empty array will execute only initial render.
If we put something inside array then this will execute only if that property will change.

useState always should define at the top of the component.
Don't use if else with state. it leads to inconsistency.

Router-config -  tells what should happen at that route.
configuration is a list array of an objects.
createBrowserRouter, RouterProvider ,Link
React-Router-Dom handle err page.
outlet replace by the child component.
In react when we have to route to a different page then should not use anchor tag because it refresh the entire page.
Link is also working the same as anchor but it does not reload the page but refresh the component.
Internally link replace by the anchor tag in the DOM.
Link is the wrapper to anchor tag react-router-dom kep track of link that it does not reload.

Two ways of Routing in web Apps
1. client-side Routing - it already has the component/page at first load.
2. server-side Routing - It makes the network call whenever we click on anchor tag thats why it reload the entire page.

class component life cycle
Mount
first thing when the class loads/mount first constructor called then render
Mounting = constructor -> render -> componentDidMount
componentDidMount is just like useEffect to call api or side effects
we call api in the above functions because react  has to quickly render and then update the data to make use experience better.
Render phase and commit phase
React batch the render phase of multiple child inside the parent to optimize.
because once the commit phase start dom update begins and it is an expensive operation
 and then commit phase of every child start together.
When we use componentWillUnmount()
when we are changing the page lots of thing we need to do
like setTimeInterval() will execute even after page change because in SPA page is not reloading.
so, clearInterval(this.timer) call inside the componentWillUnmount
Same thing in useEffect also so to clear timeout or any thing
useEffect(()=>{
 .../code
  return () => { // this will be call when component unmount

  }
})


Each components should follow SRP.
Distributing the code into smaller modules so it is easier to maintain and testable, reusable, readable.
Custom Hooks - make code more readable, modular, testable;

Need to do

Add user component to about us page.
Add custom hook inside the Menu page.
so menu will only concern about to display the data and abstract the fetching logic.
create MENU_API inside the utils to increase user experience.
Add online and offline status using customhook use online-event listener given by browser.
Add that custom hook in the body or header.

When we are working on a large application in that if bundle all the files into a single file so the size of the file will increase
so we need to optimize this otherwise it slow down the performance of an application
so the steps
chunking/code splitting/ Dynamic bundling
logical separation of bundle. bundle should have enough code to support major features.

How to create separate bundle of app/components
1./on demand loading/Lazy Loading/dynamic import - load only when demand

For Ex
const Grocery = lazy(() => import(path of the grocery)) // create different chunk for Grocery
it will show an error of suspend component because react is so fast and try to load the grocery component but that component will take 
some time to load so it throws an error.
To prevent this error we need to use Suspense component
for ex- 
<Suspense fallback = {<h1>Loading...</h1>}><Grocery></Suspense>
fallback use to load something meanwhile grocery loaded.

CSS
Sass provide super power to css.
In industry used styled components.
By using different lib and framework we can use CSS.
ex- material ui, tailwind css, bootstrap, chakra ui, ant design.
tailwind use postcss behind the scene
 Create .postcssrc in the src
 parcel need postcssrc to read tailwind.